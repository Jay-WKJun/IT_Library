# Summary

JavaScript Deep Dive 해보는 시간

ref. 코어 자바스크립트

# JavaScript의 데이터 타입과 저장 방법

프로그래밍 언어는 각자마다의 데이터 타입과 이를 저장하는 방법이 존재합니다.

primitive type이 존재하는 언어가 있는 반면, 모든 데이터가 reference type인 경우도 있습니다.

## 데이터 타입

JavaScript는 ES6 기준으로 6가지의 primitive type과 reference 형이 존재합니다.

아래 6가지가 primitive type입니다.

- number, 숫자
- string, 문자열
- boolean, 불리언
- null
- undefined
- Symbol, 심볼

reference형 데이터 타입으로는

- Object, 객체
- Array, 배열
- Function, 함수
- Date, 날짜
- RegExp, 정규표현식

이 있으며, ES6에서 추가된

- Map
- WeakMap
- Set
- WeakSet

등이 객체의 하위분류로 추가되었습니다.

## 메모리 할당

JavaScript는 각 데이터 타입별로 할당하는 메모리가 다릅니다.

- 숫자

  정수형, 부동소수형에 상관없이 **64비트 = 8바이트**의 메모리 용량이 할당됩니다.

- 문자열

  정해진 메모리 용량이 없이 문자열의 크기에 따라 동적으로 할당됩니다.

## 변수 선언 방법

JavaScript의 변수들은 기본적으로 모두 참조형이라고 할 수 있습니다.

1. 변수명(식별자)을 위한 공간 확보 \[변수 선언\]
2. 데이터 저장을 위한 공간을 따로 확보해서 데이터 저장
3. 데이터가 담긴 곳의 주소값을 변수명의 값이 있는 곳에 할당 \[데이터 할당\]

**JavaScript 기본형 타입에 대한 오해**

JavaScript의 기본형 타입들은 변수명이 담기는 곳에 데이터가 바로 담긴다고 생각하기 쉽습니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | 'asdf'

하지만, 데이터는 별개의 공간에 담기고 변수명을 저장한 곳에는 참조할 데이터의 주소값을 저장합니다.

즉, 변수명을 저장하는 공간에 데이터를 직접 담지 않습니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5000
@5000 |  | 'asdf'

### 변수명과 데이터를 따로 저장하는 이유

생각해보면 변수명과 함께 데이터를 담으면, 검색시간도 절약되고 훨씬 좋을 것 같다는 생각을 할 수 있습니다.

하지만, 2가지 측면에서 따로 담는 이점이 있습니다.

**1. 데이터 변환을 자유롭게 할 수 있음**

- 데이터를 변수명과 함께 직접 저장하는 경우

  주소값 | 변수명 | 값
  --- | --- | ---
  @1000 | a | 'asdf'

  ```javascript
  var a = 'asdf';
  a = 'aswdf';
  ```

  위와 같이 저장한 후에 변수를 갱신하는 코드가 있다고 가정했을 때, 데이터 변환을 시도해보겠습니다.

  'asdf' 사이에 'w'를 끼워넣어 a에 다시 할당하는 코드입니다.

  - 먼저 'asdf'에 맞춰 할당했던 메모리 용량을 늘립니다.

  - 후에 'df' 문자를 한칸씩 뒤로 옮깁니다.

  - 'w'를 그 사이에 끼워넣고 종료합니다.

  메모리 용량을 늘리고, 기존의 문자열을 부분적으로 조절하고, 새로 끼워넣는 과정은 굉장히 비효율적입니다.

  예시에선 'df'만 옮기면 되니 2번 반복하여 뒤로 옮기면 되지만 n번이 된다면 n번의 반복을 통해 문자열을 재배치해야하기 때문에 문제가 됩니다.

  알고리즘 문제에서도 이러한 방법은 성능적인 면에서도 비효율적입니다.


- JavaScript의 경우

  JavaScript에선 문자열을 수정하는 대신 그냥 새로운 장소에 새로운 데이터를 저장하는 방법을 사용합니다.

  주소값 | 변수명 | 값
  --- | --- | ---
  @1000 | a | @5000
  @5000 |  | 'asdf'

  ```javascript
  var a = 'asdf';
  a = 'aswdf';
  ```

  변수명 a에 'aswdf'를 새로 할당합니다. 그러면 아래와 같이 저장되게 됩니다.

  주소값 | 변수명 | 값
  --- | --- | ---
  @1000 | a | @5001
  @5000 |  | 'asdf'
  @5001 |  | 'aswdf'

  'aswdf'라는 새로운 문자열을 @5001이라는 새로운 공간에 할당해서 사용했습니다.

  이는 문자열을 수정하는 방법보다 컴퓨터 연산자원이 훨씬 적게 드는 단순한 방법입니다.

**2. 메모리를 효율적으로 관리 할 수 있음**

500개의 변수에 5라는 숫자를 할당한다고 가정하겠습니다.

변수에 직접 할당한다면, 8바이트가 할당되는 숫자를 생각한다면, ```500 * 8 = 4000바이트```바이트의 엄청난 메모리가 필요하게 됩니다.

하지만, 숫자 5를 가진 데이터 영역이 있고 이것을 500개의 데이터가 참조를 한다고 가정한다면, 주소값이 2바이트라고 했을 때, ```500 * 2 = 1000바이트```로 약 1/4로 메모리 사용량을 줄일 수 있습니다.

이처럼 변수명과 데이터를 따로 저장하는 것에는 분명한 이점이 있습니다.

## 불변값?

위에서 모든 JavaScript의 변수는 참조형이라고 했는데, 그렇다면 primitive type이 불변하다는 이야기는 무슨이야기인지 궁금해집니다!

결과부터 말씀드리면 primitive type을 담은 변수명이 불변인 것이 아닌, **데이터 그 자체가 불변**입니다.

변수명의 값은 **가변**입니다.

```javascript
var a = 't';
var b = a;
```

위와 같은 코드가 있다면, 위에서 설명한 변수와 데이터 저장 법칙에 따라 아래와 같이 저장되게 됩니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5001
@1001 | b | @5001
@5001 |  | 't'

변수명 a와 변수명 b는 같은 @5001이라는 주소값을 가지게 되었습니다.

하지만 여기서 변수들을 재할당해보겠습니다.

```javascript
a = 'qwer';
b = 'asdf';
```

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5002
@1001 | b | @5003
@5001 |  | 't'
@5002 |  | 'qwer'
@5003 |  | 'asdf'

'qwer'를 저장하는 @5002, 'asdf'를 저장하는 @5003라는 곳이 새로 생겼고 각 변수명들에 할당되었습니다.

a와 b에 할당되는 값은 달라져 **가변적**이라는 것이 확실해졌습니다.

다만, 기존의 't'라는 값은 그대로 존재하고 'qwer', 'asdf'를 담는 새로운 공간이 생겼습니다.

여기서 주목해야할 점은 't'를 담은 @5001은 변하지 않고 오로지 't'만을 담고 있어 불변이라는 점입니다. (하지만, @5001을 참조하고 있는 곳이 없어 Garbage Collector에 의해 빈 공간이 될 것입니다.)

만약 변수명에 또 새로운 데이터를 담는다면, 새로운 장소를 할당해 새로운 데이터를 저장할 것입니다.

이것이 데이터 **불변**의 원리입니다.

## 가변값?

primitive type과는 반대로 reference type은 가변적이라고 합니다.

위와 같이 JavaScript의 데이터 저장과 할당 원칙에 따라 object의 데이터 저장과 할당을 보도록 하겠습니다!

```javascript
var a = { c: 'ddd', d: 5 };
console.log(a.c);
```

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5001
@5001 |  | @7001 ~
@7001 | c | @5002
@7002 | d | @5003
@5002 |  | 'ddd'
@5003 |  | 5

primitive type에서는 변수명에 담기는 주소를 찾아가면 바로 데이터가 있었는데,

reference type에서는 변수명에 담긴 주소(@5001) -> @5001에 담긴 주소들(@7001 ~ ) -> 주소 중에 property명에 해당하는 주소(@7001) -> property명에 담긴 주소의 데이터를 찾아감(@5002) -> 'ddd'

이처럼, 변수명에 담긴 객체를 찾아가 그 안에서 데이터를 찾아야 되는 식으로 한 번 더 찾아가야되는 차이점이 있습니다.

## reference type 재할당

위와 같은 reference type의 데이터 재할당 방법으로 인해, 프로그래머 입장에서 헷갈리는 문제가 발생합니다.

아래와 같은 코드가 있다고 가정해보겠습니다.

```javascript
var a = { c: 'ddd', d: 5 };
var b = a;

b.c = 'zxcv';
console.log(a.c);
```

프로그래머의 의도는 a에 담긴 객체를 b에 복사하고 b의 c를 'zxcv'로 재할당하고 a의 c는 그대로인지 확인하려는 의도였을 것입니다.

하지만, 아래와 같이 데이터가 저장되어 있기 때문에 이 코드는 의도와는 다른 결과를 내게 됩니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5001
@1001 | b | @5001
@5001 |  | @7001 ~
@7001 | c | @5004
@7002 | d | @5003
@5002 |  | 'ddd'
@5003 |  | 5
@5004 |  | 'zxcv'

위의 데이터 테이블을 보고 데이터를 탐색해가겠습니다.

변수명 a의 탐색과정

변수명 a -> @1000 -> @5001 -> @7001 ~ -> @7001 -> @5004 -> 'zxcv'

변수명 b의 탐색과정

변수명 b -> @1001 -> @5001 -> @7001 ~ -> @7001 -> @5004 -> 'zxcv'

따라서 ```a.c```와 ```b.c```의 결과는 'zxcv'로 같습니다.

b.c만 바꿨는데도 a.c까지 바뀌게 되었습니다.

**그 이유는 변수명 a와 b가 @5001에 담긴 똑같은 객체를 같이 바라보고 있기 때문입니다.**

## 객체 복사

그렇다면 원하는대로 객체를 복사해서 사용하고 싶다면 어떻게 하면 좋을까요?

직관적으로 생각되는 방법은, 객체를 새로 생성하고 객체 내부의 프로퍼티들은 그대로 복사해서 가져오는 방법을 생각할 수 있습니다.

그리고 이건 만약 객체 내부에 객체가 또 있다고 하면 같은 방법으로 복사할 수 있을 것입니다. (깊은 복사)

그럼 객체를 복사해보겠습니다!

```javascript
var copyObjectDeep = function(target) {
  var result = {};
  if (typeof target === 'object' && target !== null) {
    for (var prop in target) {
      result[prop] = copyObjectDeep(target[prop]);
    }
  } else {
    result = target;
  }

  return result;
}

var a = { c: 'ddd', d: 5 };
var b = copyObjectDeep(a);

b.c = 'zxcv';
console.log(a.c);  // ddd
```

새로운 객체를 생성하고 기존의 프로퍼티를 옮겨 담았습니다.

그러면 어떻게 데이터들이 저장되어 있는지 살펴보겠습니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5001
@1001 | b | @5002
@5001 |  | @7001 ~
@5002 |  | @8001 ~
@7001 | c | @5002
@7002 | d | @5003
@8001 | c | @5004
@8002 | d | @5003
@5002 |  | 'ddd'
@5003 |  | 5
@5004 |  | 'zxcv'

위의 데이터 테이블을 보고 데이터를 탐색해가겠습니다.

변수명 a.c의 탐색과정

변수명 a -> @1000 -> @5001 -> @7001 ~ -> @7001 -> @5002 -> 'ddd'

변수명 b.c의 탐색과정

변수명 b -> @1001 -> @5002 -> @8001 ~ -> @8001 -> @5004 -> 'zxcv'

이제 변수명 a는 @7001 ~ 객체를, 변수명 b는 @8001 ~ 객체를 바라보게 되어 서로 다른 객체를 바라보게 되었습니다.

따라서 b.c를 재할당해도 a.c는 영향받지 않게 되었습니다!

## undefined

JavaScript에는 비어있다는 뜻의 데이터 타입으로 undefined와 null이 존재합니다.

헷갈릴 수 있으므로 둘의 정의를 확실히 하는 편이 좋습니다.

undefined 타입은 JavaScript 엔진이 자동으로 지정 혹은 반환해주는 타입으로 **사용자가 응당 어떤 값을 지정할 것이라고 예상되는 상황임에도 실제로는 그렇게 하지 않았을 때 undefined를 반환**합니다.

다음 3가지의 경우에 해당합니다.

1. 값을 대입하지 않은 변수, 즉 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

1번의 경우, var 변수를 선언하고 데이터를 할당하지 않았을 때가 대표적입니다.

```javascript
var a;
console.log(a) // undefined
```

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a |

변수명 a의 저장 장소인 @1000에 데이터 주소값이 할당되지 않은 상태로 있으므로, JavaScript 엔진은 undefined를 반환합니다.

(참고로 let, const는 var와는 다르게 선언 후 데이터를 할당하지 않으면 접근조차 할 수 없습니다. 접근하려하면 에러입니다.)

2번의 경우는 다음과 같습니다.

```javascript
var a = {};
console.log(a.c) // undefined
```

a에 할당된 객체에는 c라는 프로퍼티가 없으므로 undefined를 반환합니다.

그런데 여기서 헷갈리는 경우가 있습니다.

```javascript
var a = {};
console.log(a.[0]); // undefined

var b = {
  0: undefined,
};
console.log(b.[0]); // undefined
```

두 개의 경우 같은 undefined의 결과이지만, 컴퓨터 내부적으로 보면 조금 다릅니다.

주소값 | 변수명 | 값
--- | --- | ---
@1000 | a | @5000
@1001 | b | @5001
@5000 |  | @7001 ~
@5001 |  | @8001 ~
@8001 | 0 |

변수명 a.0의 탐색과정

변수명 a -> @1000 -> @5000 -> @7001 ~ (0 값을 검색했으나 없음) -> undefined

변수명 b.0의 탐색과정

변수명 b -> @1001 -> @5001 -> @8001 ~ -> @8001 -> 없음 -> undefined

b의 경우 @8001이라는 실존하는 데이터이지만, 할당된 데이터 주소값이 없는 반면 a는 정말 property 자체가 존재하지 않아 찾을 수 없어 undefined를 반환한 것입니다.

**즉, 실존하는 데이터에 할당된 데이터 주소가 없는 경우, 정말로 값 자체가 없는 경우로 나뉠 수 있습니다.**

따라서 이런 헷갈리는 상황을 줄이기 위해 빈 property에는 null이라는 데이터를 대신 할당해 줄 수 있습니다.

# 실행 컨텍스트

실행 컨텍스트란, 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.

어떤 실행 컨텍스트가 활성화되는 시점에 여러 동작을 수행하게 되는데,

- 선언된 변수를 위로 끌어올려 변수명을 수집(호이스팅)
- 외부 환경 정보를 구성
- this 값을 설정

등등 여러 동작을 수행합니다.

이 과정에서 JavaScript는 다른 언어와는 다른 JS만의 독특한 동작들이 있습니다.

헷갈릴 수 있으니 주의하도록 해야겠습니다 😵‍💫

## 여러 실행 컨텍스트들의 저장과 실행

실행 컨텍스트가 실행할 코드에 제공할 환경 정보들을 모아놓은 객체라는 것을 알겠는데, 실제 앱에서는 수많은 실행 컨텍스트들이 실행될텐데 이것들은 어떤 순서로 어떻게 실행될까요?

### call stack

실행 컨텍스트들은 call stack에 저장되었다가 실행됩니다.

즉, FILO (First In Last Out) 순서로 실행되기 때문에, 가장 마지막에 생성된 실행 컨텍스트 들이 가장 먼저 실행됩니다.

## 실행 컨텍스트를 구성하는 방법과 종류

실행 컨텍스트는 **'동일한 환경'**에 있는 코드들을 실행할 때, 필요한 환경 정보들을 모아 컨텍스트를 구성합니다.

여기서 '동일한 환경'의 범위는 아래와 같습니다.

- 전역공간
- eval() 함수
- 함수

여기서 전역공간은 자동으로 생성되는 것으로 프로그래머의 영향력 밖이고,

eval()은 정말 특별한 경우가 아니면 사용하지 않고, ```eval is evil```이란 말이 있듯이... 거의 금기로 여겨지는 기능이므로

결국 **함수**를 실행하는 것만이 실행 컨텍스트를 구성하는 방법임을 알 수 있습니다.

(다만, 함수만 실행 컨텍스트를 만든다는 것은 ES5까지만 그랬었고 ES6부터는 중괄호({})도 실행 컨텍스트를 형성하게 되어있습니다.

중괄호 범위로 형성된 컨텍스트 범위를 '블록 스코프'라고 하며 let, const, class, strict mode 등이 대표적으로 블록 스코프에서만 활용할 수 있는 것들입니다.)

## 실행 컨텍스트의 구성

실행 컨텍스트는 크게 3가지로 구성되어 있습니다.

- Variable Enviroment

  Lexical Enviroment와 같은 내용을 저장하지만, **오로지 초기값 snapshot**만을 가지고 있습니다.

  - enviroment Record(snapshot)

  - outer Enviroment Reference(snapshot)

- Lexical Enviroment

  Variable Enviroment와 같은 내용을 저장하지만, **시시각각 변하는 정보를 저장합니다.**

  - enviroment Record

  - outer Enviroment Reference

- ThisBinding

### enviroment Record와 호이스팅

**현재 컨텍스트와 관련된 코드의 식별자 정보들이 <u>순서대로</u> 저장됩니다.**

컨텍스트를 구성하는 함수에 지정된 **매개변수 식별자**

함수 선언이 있을 경우 **함수 그 자체**

var로 선언된 **변수의 식별자**

위 3가지가 식별자에 해당합니다.

이 정보 수집은 코드가 실행되기 전에 모두 수집되게 되는데,

이러한 행동이 '자바스크립트 엔진은 식별자들을 최상단으로 끌어놀려놓은 다음 실제 코드를 실행한다'라고 생각하게 만드는 원인일 것입니다!

여기서 **'호이스팅(hoisting)'**이라는 개념이 등장하는데, '끌어올리다'라는 뜻으로,

식별자들을 끌어올려 enviroment Record에 기록한 뒤, 해당 변수에 데이터를 할당하는 코드가 나올 때,

데이터를 할당한다 라는 식으로 직관적으로 이해하기 위한 가상의 개념입니다!

